# JavaScript 

## DOM
HTML은 순서가 유의미하다. 
중첩관계(부자관계)를 가진다.

브라우저 동작
1. 주소창에 주소를 입력하면(google.com)    
   주소 뒤에 리소스가 없으면 index.html을 서버가 반환한다.  
2. 브라우저가 서버에게 웹페이지를 요청한다.  (도메인 주소에 있는 서버에게)  

3. 웹페이지를 받으면 파싱한다.(읽는다.)    
4. 이후 DOM tree를 만든다.  
5. 읽다가 link 태그의 css파일을 만난다. 그러면 파싱을 멈춘다.      
6. 서버에 css을 요청한다.  
7. css를 읽는다.  
8. 이후 CSSOM tree를 만든다.  
9. 이후 읽다가 script 태그를 만난다. 그러면 파싱을 멈춘다.    
10. 서버에 script 파일을 요청한다.  
11. script 파일을 받는다.  

서버에게 요청한 것을 받는 과정은 문자열(아스키코드)로 패킷화해서 받는다.  

하나의 요소 노드 선택(DOM Query)  
1. document.getElementById(id)  
  - id 어트리뷰트 값으로 요소 노드를 한 개 선택한다. 복수개가 선택된 경우 첫번째 요소만 반환한다.  
  ex) var elem = document.getElementById('one');  
      elem.className = 'blue';  
2. document.querySelector(cssSelector)  
  - CSS 셀렉터를 사용하여 요소 노드를 한 개 선택한다. 복수개가 선택된 경우 첫번째 요소만 반환한다.  
  ex) var elem = document.querySelector('li.red');  
      elem.className = 'blue';  

여러 개의 요소 노드 선택(DOM Query)  
1. document.getElementsByClassAnme(class)  
  - class 어트리뷰트 값으로 요소 노드를 모두 선택한다. 공백으로 구분하여 여러 개의 class를 지정할 수 있다.  
  - HTMLCollection(live)    
  ex) var elems = document.getElementsByClassName('red');  
      for (var i = 0; i < elems.length; i++) {  

      elems[i].className = 'blue';  
      }  

  length는 3인데 i가 0 일때 첫 요소의 class를 블루로 바뀌면 실시간으로 상태 변경을하는 HTMLCollection 객체로 인해 제거된다.  
  이후 두번째 요소가 index값을 0으로 갖게되고 세번째 요소가 index값을 1로 갖게된다.  
  그러면 i가 1 일때 세번째 요소의 class를 블루로 바뀐다.  
  따라서 두번째 요소의 class는 바뀌지 않는다.  

  이러한 문제를 회피할 수 있는 방법으로는 반복문을 역으로 돌리거나 배열로 변경한다.  
  ex) var elems = document.getElementsByClassName('red');
      
  // elems(HTMLCollection)을 배열로 변경.  
  var arr = Array.slice.call(elems);  

  for (var i = 0; arr.length > 0; i++) {  
        
  arr[i].className = 'blue';  
}  
2. document.querySelectorAll(selector)
  - 지정된 CSS 선택자를 사용하여 요소 노드를 모두 선택한다.  
  - NodeList(non-live)  
  ex) var elems = document.querySelectorAll('li.red');

      for (var i = 0; i < elems.length; i++) {

      elems[i].className = 'blue';
      }  

DOM 탐색  
1. parentNode  
  - 부모 노드를 탐색한다.  
  - HTMLElement를 상속받은 객체.  

2. firstChild, lastChild  
  - 자식 노드를 탐색한다.  
  - HTMLElement를 상속받은 객체.
  ex) 
  // 부모 요소를 선택  
  var elem = document.querySelector('ul');  

  elem.firstChild.className = 'blue';  
  elem.lastChild.className = 'blue';   

3. hasChildNodes()  
  - 자식 노드가 있는지 확인하고 Boolean 값을 반환한다.  

4. childNodes  
  - 자식 노드의 컬렉션을 반환한다.  
  - NodeList(non-live)  

5. previousSibling, nextSibling  
  - 형제 노드를 탐색한다.  
  - HTMLElement를 상속받은 객체.  

DOM 조작  
1. 텍스트 노드에 접근/수정  
  - 요소의 텍스트는 텍스트 노드에 저장되어 있다.  

  텍스트 노드에 접근하는 순서  
  1-1. 해당 텍스트 노드의 부모 노드를 선택한다.(텍스트 노드는 요소 노드의 자식이다.)  
  1-2. firstChild 프로퍼티를 사용하여 텍스트 노드를 탐색한다.  
  1-3. 텍스트 노드의 유일한 프로퍼티 nodeValue를 이용하여 텍스트를 취득한다.  
  1-4. nodeValue를 이용하여 텍스트를 수정한다.  

  nodeValue  
    - 노드의 값을 반환한다.  
    - 텍스트 노드의 경우는 문자열, 요소 노드의 경우 null 반환.  

2. HTML 콘텐츠 조작  

  innerHTML  
    - 해당 요소의 모든 자식 요소를 포함하는 모든 콘텐츠를 하나의 문자열로 취득할 수 있다.  
    - 마크업을 포함한다.  
    - 크로스 스크립팅 공격에 취약하다.  

3. DOM 조작 방식  
  - innerHTML 프로퍼티를 사용하지 않고 새로운 콘텐츠를 추가할 수 있는 방법은 DOM을 직접 조작하는 것이다.  

  createElement(tagName)  
    - 태그 이름을 인자로 전달하여 요소를 생성한다.  
  
  createTextNode(text)  
    - 텍스트를 인자로 전달하여 텍스트 노드를 생성한다.  
  
  appendChild(Node)  
    - 인자로 전달한 노드를 자식 요소로 DOM 트리에 추가한다.  

//태그이름을 인자로 전달하여 요소를 생성  
var newElem = document.createElement('li');    

// 텍스트 노드를 생성  
var newText = document.createTextNode('Beijing');  

// 텍스트 노드를 newElem 자식으로 DOM 트리에 추가  
newElem.appendChild(newText);  

var container = document.querySelector('ul');  

// newElem을 container의 자식으로 DOM 트리에 추가  
container.appendChild(newElem);  

var removeElem = document.getElementById('one');  

// container의 자식인 removeElem 요소를 DOM 트리에 제거한다.  
container.removeChild(removeElem);  




