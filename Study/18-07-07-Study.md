# 러버덕

1. 객체  
기본 자료형을 제외한 나머지 값들(함수, 배열 등)은 모두 객체이며,  
데이터와 데이터에 관련된 동작을 모두 포함할 수 있는 개념적 존재이다.    
또한 키와 값으로 구성된 데이터를 의미하는 프로퍼티와 동작을 나타내는 메소드로 구성된 집합이고, 구성 요소들의 순서를 보장하지 않는다.    
객체지향의 상속을 구현하기 위해 프로토타입이라고 불리는 객체의 프로퍼티와 메소드를 상속받을 수 있다.  

2. pass-by-value vs pass-by-reference  
pass-by-value는 값을 복사하여 전달하고, pass-by-reference는 참조값을 전달한다.  
따라서 복사한 값을 전달한 pass-by-value는 원본 변경이 되지 않으며, 참조값을 전달한 pass-by-reference는 원본이 변경 된다.  

3. 호이스팅  
모든 선언문이 선언되기 이전에 참조 가능한 것을 호이스팅이라 한다.  
변수 호이스팅은 변수 정의 전에 변수를 참조하면 undefined 값이다.  
함수 선언식으로 정의된 함수는 함수 선언, 초기화, 할당이 한번에 이루어지기 때문에 함수 선언의 위치와 상관없이 어느 곳에서든 호출이  가능하다.  
함수 표현식으로 정의된 함수는 변수 호이스팅이 발생한다.      


4. mutable vs immutable  
mutable은 값이 변경 가능하며, immutable은 값이 변경 불가능하다.  


5. 일급 객체  
객체를 대입, 연산, 인자 또는 반환값으로서의 전달을 제한없이 사용할 수 있는 대상이다.  
    - 무명의 리터럴로 표현이 가능하다.  
    - 변수나 자료 구조에 저장할 수 있다.  
    - 함수의 파라미터로 전달할 수 있다.  
    - 반환값으로 사용할 수 있다.  


6. call-by-value vs call-by-reference  
call-by-value는 함수 호출 시 기본 자료형 인수를 함수에 매개변수로 전달할 때 매개변수에 값을 복사하여 전달하는 방식이고, call-by-reference는 함수 호출 시 참조 타입 인수를 함수에 매개변수로 전달할 때 매개변수에 참조값이 전달되는 방식이다.   


7. 콜백 함수  
함수를 명시적으로 호출하는 방식이 아니라 특정 이벤트가 발생했을 때 시스템에 의해 호출되는 함수이다.  
