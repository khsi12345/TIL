# ECMAScript 6

## 러버덕  
1. var vs let vs const  
var는 변수 호이스팅으로 선언과 초기화가 동시에 진행된다.  
함수 레벨 스코프만 지원한다.  
전역 변수 남발 및 변수 중복 사용으로 인한 의도치 않은 설계.  

let은 함수 레벨 스코프와 블록 레벨 스코프도 지원한다.    
재할당이 필요하면 사용한다.  
변수 호이스팅이 안되는 것처럼 동작하는데, 선언과 초기화가 분리되어 진행되기 때문이다.  


const는 함수 레벨 스코프와 블록 레벨 스코프도 지원한다.  
재할당을 안할때 사용한다.    
변수 호이스팅이 안되는 것처럼 동작하는데, 선언과 초기화가 분리되어 진행되기 때문이다.  

2. This  
기본적으로 전역 객체(window)를 참조한다.  
함수 호출에 따라 this는 참조하는 것이 다르다.  
일반 함수는 this는 전역 객체(window)를 참조한다.  
콜백 함수는 this 전역 객체(window)를 참조한다.  
전역 객체(window) 참조하는 것을 회피하는 방법으로
- 변수에 this를 할당해서 변수로 사용한다.  
메소드에서 사용하는 this는 메소드를 호출하는 객체를 참조한다.  
화살표 함수는 무조건 상위 컨텍스트로부터 this를 계승 받는다.  


## 디스트럭처링  
구조화된 배열 또는 객체를 비구조화, 파괴하여 개별적인 변수에 할당하는 것.  
배열 또는 객체 리터럴에서 필요한 값만을 추출하여 변수에 할당하거나 반환할때 유용하다.  

배열과 객체의 차이  
배열은 순회가능하다, 객체는 순서가 무의미하다.  
객체는 메소드를 가지고, 배열은 데이터(값)만 가진다.  


1. 배열 디스트럭처링  
배열에 데이터가 있는데 그 데이터 중 필요한 데이터만(개별젹인 요소) 가져온다.  

2. 객체 디스트럭처링  
객체에 있는 프로퍼티를 객체로부터 디스트럭칭하여 변수에 할당하기 위해서는 프로퍼티 이름(키)를 사용해야 한다.  


## Class  
클래스의 이름은 첫 글자를 대문자로 사용한다.  
생성자 함수는 인스턴스 생성시 new를 빼도 에러가 발생하지 않지만 Class는 new를 빼면 에러가 발생한다.  
Class에는 반드시 constructor가 1개가 존재해야하고 생략 가능하다. 
Class 프로퍼티의 선언과 초기화는 반드시 constructor 내부에서 실시한다.  


getter: 클래스 프로퍼티에 접근할 때마다 클래스 프로퍼티의 값을 조작하는 행위가 필요할 때 사용한다.  
파라미터가 없다.  
반드시 리턴해야한다.  


setter:  클래스 프로퍼티에 값을 할당할 때마다 클래스 프로퍼티의 값을 조작하는 행위가 필요할 때 사용한다.  
값을 할당해야하기 때문에 파라미터가 존재한다.  


클래스 상속  
재사용 관점에서 매우 유용하다.  
extends 키워드는 부모 클래스를 상속받는 자식 클래스를 정의할 때 사용한다.  
자식 클래스의 constructor 내부에서 super로 부모 클래스의 constructor를 호출한다.  


## Promise  

Ajax의 단점  
콜백 헬이라는 현상이 발생하다.  
에러 처리가 불가능하다.  

콜백 헬  
콜백 함수를 사용하면 처리 순서를 보장하기 위해 여러 개의 콜백 함수가 중첩되어 복잡도가 높아지는 현상.  

위 문제점들을 보완하기 위해 사용한다.  


Promise 생성자 함수를 통해 인스턴스화한다.  

// Promise 객체의 생성  
// 비동기 작업을 수행할 콜백 함수를 인자로 전달받는데 콜백 함수로 resolve와 refect를 인자로 전달 받는다.  
const promise = new Promise((resolve, reject) => {  
  // 비동기 작업을 수행한다.  

  if (/* 비동기 작업 수행 성공 */) {  
    resolve('result');  
  }  
  else { /* 비동기 작업 수행 실패 */  
    reject('failure reason');  
  }  
});  

비동기 처리가 성공하였는지 또는 실패하였는지 등의 상태 정보를 갖는다.  

   상태               의미                            구현
fulfilled:	비동기 처리가 수행된 상태 (성공)	resolve 함수가 호출된 상태  
rejected: 비동기 처리가 수행된 상태 (실패)	reject 함수가 호출된 상태  

get(url)  
  .then(result => document.getElementById('result').innerHTML = result)  
  .catch(error => console.log(error));  

// result에는 resolve 메소드의 처리 결과 값이 들어간다.  
// error에는 reject 메소드의 처리 결과 값이 들어간다.  






