# Angular

## 러버덕

1. @Input(), @Output()

  @Input 데코레이터는 자식 컴포넌트가 부모 컴포넌트에게 상태 정보를 전달 받을 때 사용한다.  
  부모 컴포넌트는 템플릿에 있는 자식 컴포넌트의 태그에 프로퍼티 바인딩으로 상태 정보를 전달한다.  
  
  @Output 데코레이터는 자식 컴포넌트에서 이벤트가 발생했을 때 상태 정보를 부모 컴포넌트에게 전달한다.  
  이때 Output 데코레이터에게 장식된 프로퍼티에 EventEmitter 생성자 함수의 인스턴스를 할당해서 .emit 메소드를 사용한다.  
  부모 컴포넌트는 템플릿에 있는 자식 컴포넌트의 태그에 이벤트 바인딩으로 상태 정보를 전달 받는다.  

2. generic

  자바스크립트는 동적 타이핑 언어로서 값이 할당 될 때 타입이 정해지므로 타입과 관련된 문제들이 많이 발생하는데 이 문제들을 보완하기 위해  
  타입스크립트나 generic을 사용한다.  
  generic은 생성 시점에 타입을 명시하여 다양한 타입을 사용할 수 있다.  



## Life Cycle

  Angular가 관리하지는 않지만 가장 먼저 constructor() 생성자 함수(ES6, 타입스크립트 문법)가 실행 되고 ngChangeInit() 실행 후 ngOnInti()이 실행된다.  
  ngOnInit()은 컴포넌트의 모든 프로퍼티의 초기화가 완료되면 실행된다. 

## service  

  컴포넌트의 관심사와 애플리케이션 전역의 관심사를 분리하는 것이다.  
  서비스는 의존성 주입이 가능한 클래스로 @Injectable 데코레이터는 자신의 아래에 정의된 클래스가 의존성 주입이 가능한 클래스임을 나타낸다.  


  6. 서비스 중재자 패턴

    서비스를 컴포넌트 간 데이터 중재자로 사용하면 일정한 형식의 자료 구조를 사용하면서 컴포넌트 간의 상태 공유가 가능하다.  
    

## RxJS

  모든 인풋(함수, 이벤트, 배열 등)을 데이터 스트림으로 모은다. 

  필요한 데이터를 획득하기 위해서 애플리케이션이 외부 환경에 요청하여 데이터를 획득하는 것이 아니라, 애플리케이션은 외부 환경을 관찰하고 있다가 외부 환경에서 데이터 스트림을 방출하면 그것에 반응하여 데이터를 획득하는 방식이다.  

  외부 환경에서 애플리케이션으로 연속적으로 흐르는 데이터 즉, 데이터 스트림을 생성하고 방출하는 객체를 옵저버블이라고 하고, 옵저버블이 방출한 노티피케이션을 획득하여 사용하는 객체를 옵저버라고 한다.  

  옵저버는 옵저버블을 구독한다.  

  이 구독에 의해 옵저버는 옵저버블에 연결되어 옵저버블의 상태를 관찰한다.  

  데이터는 노티피케이션에 담긴다.  


## HttpClient와 Http 통신

